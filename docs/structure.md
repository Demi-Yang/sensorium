## 程序目标
- 深度解耦合
- 可读性
- 可配置性
- 重试
- 超时
- 版本
- 统一硬件协议调用接口，统一版本号，统一单元测试。为应用开发提供支持。

## 实现思路
- 文件内部功能单一化：一个文件一个类，实现一种功能，不把过多的功能聚合在一起，增加可读性和可维护性。使用node的require和export来维护文件依赖。
- 好的代码应该是简洁的，单元功能独立，可读性强，用代码来解释文档

## 技术路线
- nodejs书写
- webpack
- restful api

## 功能部分
- 连接部分
    - 蓝牙连接
    - 2.4G连接
    - wifi连接
- 主板部分
- 协议部分
- 发送指令
    - send
    - 重试
- 解析指令
    - parse asciima
    - parseGcode
    - 结果

## 类的划分
- Command
    - 说明：发送指令
    - 属性
    - 方法
        - send
        - doSend
        - parse
        - doParse
- MainBoards
有一个主板类，
    - 方法：
        - 获取固件版本号
        - 获取主板名称
- 定义每个电子模块的基本协议格式
    - 名称
    - 设备类型

### 程序结构
- docs/ 文档
- src/ 主要源码部分
    - protocol/ 各主控板协议定义
        - common/ 各平台都一致的模块
        - mcore/
        - orion/
        - auriga/
        - megaPi/
    - driver/ 各平台api驱动逻辑
- browser/ 存放浏览器引擎文件
- test/ 测试相关
- package.json
- README.md

协议部分中使用文件夹在组织模块，是为了使程序结构更小单元。

## 步骤
- []构建文件结构
- []定义基本类
- []nodejs事件的写法

### 第一步：实现数据协议发送，确定接口名称
- [x]基于已有的程序结构实现
- [x]选择主板实现
- [x]完成读取传感器数值的逻辑部分
    - [x]基本协议发送
    - [x]模拟读取传感器的数值
    - [x]超时重发
- [x]利用browerify生成浏览器可以以后用的代码，命名为sensorium.js，进行测试
    - 需要把主类通过window对象export出去
- []定义接口名称

### 第二步：实现数据接管
- []定义数据层，接收并解析数据
- []不同协议做版本区分
- []跑通蓝牙部分
- []在mblock上进行测试

## 协议列表
### 读命令
1. 软件版本号
1. 超声波传感器
1. 温度传感器(18B20)
1. 光线传感器
1. 电位器
1. 摇杆
1. 姿态传感器(MPU6050)
1. 音量传感器(MIC)
1. 温度传感器(板载)
1. 红外传感器
1. 被动式红外探测器
1. 寻线传感器
1. 限位器
1. 电子罗盘
1. 温湿度传感器
1. 火焰传感器
1. 气体传感器
1. 读取数字管脚的值
1. 读取模拟管脚的
1. 读取管脚的脉冲持续时间
1. 双管脚超声波传感器
1. 固件运行时间
1. 触摸传感器
1. 4按键模块
1. 编码电机(板载)
1. 主板通用命令

### 执行命令
1. 直流电机
1. 编码电机(板载）
1. 摇杆1
1. 摇杆2
1. 步进电机
1. RGB LED灯
1. 主板通用命令
1. 数字舵机
1. 四位七段数码管
1. 表情面板
1. 光线灰度传感器
1. 快门线模块
1. 设置数字管脚
1. 设置PWM输出
1. 设置TONE输出
1. 数字舵机2
1. 固件运行时间
1. 编码电机(外接)


### 代码规范
- 4个空格代替tab
- 注释采用jsDoc规范
- 文件名称统一采用`_`连接


### 参考资源
- [api 书写格式](http://johnny-five.io/examples/sensor/)


基本方法：
constructor
get set

变成配置，好处就是处理方法可用集中化。

类，方法和属性

var board = new Board("auriga");

board.version // "v0e.1.102", 版本号
board.modeList // 可用的模式列表，[巡线，超声波，蓝牙，红外，自平衡]
board.mode // 当前模式


-------- 实现1 --------
优点：结构比较清晰
-----------------------
board.getVoltage() 获取电压
board.Led.setColor(port,r,g,b) // 基本模式
         .turnOff()
         .blink()
board.Tone.playTone(buzzer, beat) // 基本模式

board.Sensor.getStatus(
{
    "type": "ultrasonic", // 对应到device中的序号
    "port": 3,
    "slot": 1

}, function(val) {
    // use val.
});

-------- 实现2 -------------------------------
优点：对外接口比较统一，做为底层基础协议，使用该思路
----------------------------------------------
通用的方法
board.getVoltage() 获取电压

board.getBlockStatus({
    "type": "ultrasonic", // 对应到device中的序号
    "port": 3,
    "slot": 1
}, function(val) {
    // use val.
})

board.sendCommand({
    type: "led_matrix",
    port: 3,
    slot: 1,
    color: [r,g,b]
});


### 数据层
数据全部交到引擎，引擎提供给上位机，而不是由固件直接提供给上位机。需要一个数据层，用来
提供数据给使用者。每次路径是：

获取传感器的值：
应用层发送获取指令-> 引擎接收到发送请求-> 发送给接口层 -> 接口发送给硬件 -> 硬件返回数据给接口 ->

接口通道返回给引擎 -> 引擎处理数据 -> 提交到数据层 -> 数据层上报给应用层。

拆分的好处是，每个环节都可以解耦合，对于应用，只需要发送数据，接收数据。

所有的行为都是异步的，因此采用中间数据层来提供数据管理员角色，所有数据由硬件传递到该层，
更新该层的数据模型。所有的上层从该层取数据，引擎负责定时更新该层数据。
上层不直接参与到与底层硬件的数据对接。

涉及到上报模式。
1. 用户发送一条传感器的读值请求
2. 注册该读值请求定时器
3. 数据层注册该传感器数值索引
4. 启动定时器，定时更新数据层中对应索引的数值
5. 返回该数值


### 其他
实例化主板，主板下会加载对应模块的协议。

先写一个完整的主线，然后从该代码结构中拆分各模块，形成其他模块。

发应该和收放在同一个类中（这是主线）

发送一条指令过程：
1. 触发command中的send
2. 从protocol + electronic 组织成具体的协议
3. 调用command中的doSend 进行发送
