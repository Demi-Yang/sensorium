## TODO
- 程序是对数据结构的实现
- 遵循原则：简洁，命名、注释等，可要可不要的就不要
- 使用 fesc 来约定代码格式
- 使用 .editorconfig 来约定格式规范
- 参考 http://km.makeblock.com/pages/editpage.action?pageId=11080426

### 待更改地方
- 变量命名：类用大写；变量、对象使用驼峰式，首字母小写
- 命名、注释的简洁性，可要可不要的名称就不要，例如：
  - execWrite -> write
  - execRead -> read
- 单词尽量选常用可理解的
  - exec -> send
- 单个模块下尽量不出现多个层级的文件夹，而考虑使通过文件命名形式来处理
  - /src/electronic/base/ 文件夹
  - /src/mainboard/firmware/ 文件夹
- 函数与函数之间空一行
- 测试

### 命名
`execFunc`、`callbackProxy`


### DONE
- [x]发布一个npm包，实现串口连接主板调试
- [x]实现在线蓝牙版本
- [x] auriga缺的接口包括：外接编码电机、表情面板、快门线模块、设置TONE输出、智能舵机；以及所有的读指令
- [x] auriga.js中每个接口都需要加上返回值


`/src/commnunicate/read.js` 中的问题记录：
//当前问题：发送请求超过 255 个时，进行了暴力覆盖。但是根据协议 index 大小，又只能识别 255 条请求

// 控制方案一(待整理):
//首先其 exec 将被控制执行，需完成以下动作后才执行：
//1、加入监听列队（第二队）时，先做监听列队分析————对一队列剔除哪些位于中间的、占位较多的监听器到垃圾箱
//2、一旦有数据返回，触发对应监听器，同时做关联分析，砍掉一批。同时清空垃圾箱
//3、执行这个 exec
//4、直到第二队也到达 255.
//5、选出列队一空缺的位置（指针拨到1，表明1需要彻底清理）

// 控制方案二:
//1、允许快速产生 255 条请求（或采用一定的节流方案）
//2、将请求保存在一个队列中（保存请求发起时间）
//3、再新增请求时，检查是否满队列，若满执行第6条。必须满足队列中有空位让出——也求是请求有返回值回来——才能进入队列中
//4、新增请求占领空位（需计算空位index），并执行发送
//5、后续请求依次遵循这个规则
//6、满队列的情况下，新增请求时清空那些超时（2s?）的请求，再进入

// 将异步用 promise 来做
// typescript 来重构部分代码


